var rrwebSnapshot = (function (exports) {
  'use strict';

  (function (NodeType) {
      NodeType[NodeType["Document"] = 0] = "Document";
      NodeType[NodeType["DocumentType"] = 1] = "DocumentType";
      NodeType[NodeType["Element"] = 2] = "Element";
      NodeType[NodeType["Text"] = 3] = "Text";
      NodeType[NodeType["CDATA"] = 4] = "CDATA";
      NodeType[NodeType["Comment"] = 5] = "Comment";
  })(exports.NodeType || (exports.NodeType = {}));

  var _id = 1;
  function genId() {
      return _id++;
  }
  function getCssRulesString(s) {
      try {
          var rules = s.rules || s.cssRules;
          return rules
              ? Array.from(rules).reduce(function (prev, cur) { return prev + getCssRuleString(cur); }, '')
              : null;
      }
      catch (error) {
          return null;
      }
  }
  function getCssRuleString(rule) {
      return isCSSImportRule(rule)
          ? getCssRulesString(rule.styleSheet) || ''
          : rule.cssText;
  }
  function isCSSImportRule(rule) {
      return 'styleSheet' in rule;
  }
  function extractOrigin(url) {
      var origin;
      if (url.indexOf('//') > -1) {
          origin = url
              .split('/')
              .slice(0, 3)
              .join('/');
      }
      else {
          origin = url.split('/')[0];
      }
      origin = origin.split('?')[0];
      return origin;
  }
  var URL_IN_CSS_REF = /url\((?:'([^']*)'|"([^"]*)"|([^)]*))\)/gm;
  var RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/).*/;
  var DATA_URI = /^(data:)([\w\/\+]+);(charset=[\w-]+|base64).*,(.*)/gi;
  function absoluteToStylesheet(cssText, href) {
      return cssText.replace(URL_IN_CSS_REF, function (origin, path1, path2, path3) {
          var filePath = path1 || path2 || path3;
          if (!filePath) {
              return origin;
          }
          if (!RELATIVE_PATH.test(filePath)) {
              return "url('" + filePath + "')";
          }
          if (DATA_URI.test(filePath)) {
              return "url(" + filePath + ")";
          }
          if (filePath[0] === '/') {
              return "url('" + (extractOrigin(href) + filePath) + "')";
          }
          var stack = href.split('/');
          var parts = filePath.split('/');
          stack.pop();
          for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
              var part = parts_1[_i];
              if (part === '.') {
                  continue;
              }
              else if (part === '..') {
                  stack.pop();
              }
              else {
                  stack.push(part);
              }
          }
          return "url('" + stack.join('/') + "')";
      });
  }
  function absoluteToDoc(doc, attributeValue) {
      var a = doc.createElement('a');
      a.href = attributeValue;
      return a.href;
  }
  function isSVGElement(el) {
      return el.tagName === 'svg' || el instanceof SVGElement;
  }
  function serializeNode(n, doc, blockClass, inlineStylesheet) {
      switch (n.nodeType) {
          case n.DOCUMENT_NODE:
              return {
                  type: exports.NodeType.Document,
                  childNodes: []
              };
          case n.DOCUMENT_TYPE_NODE:
              return {
                  type: exports.NodeType.DocumentType,
                  name: n.name,
                  publicId: n.publicId,
                  systemId: n.systemId
              };
          case n.ELEMENT_NODE:
              var needBlock_1 = false;
              if (typeof blockClass === 'string') {
                  needBlock_1 = n.classList.contains(blockClass);
              }
              else {
                  n.classList.forEach(function (className) {
                      if (blockClass.test(className)) {
                          needBlock_1 = true;
                      }
                  });
              }
              var tagName = n.tagName.toLowerCase();
              var attributes_1 = {};
              for (var _i = 0, _a = Array.from(n.attributes); _i < _a.length; _i++) {
                  var _b = _a[_i], name = _b.name, value = _b.value;
                  if (name === 'src' || name === 'href') {
                      attributes_1[name] = absoluteToDoc(doc, value);
                  }
                  else if (name === 'style') {
                      attributes_1[name] = absoluteToStylesheet(value, location.href);
                  }
                  else {
                      attributes_1[name] = value;
                  }
              }
              if (tagName === 'link' && inlineStylesheet) {
                  var stylesheet = Array.from(doc.styleSheets).find(function (s) {
                      return s.href === n.href;
                  });
                  var cssText = getCssRulesString(stylesheet);
                  if (cssText) {
                      delete attributes_1.rel;
                      delete attributes_1.href;
                      attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);
                  }
              }
              if (tagName === 'style' &&
                  n.sheet &&
                  !n.innerText.trim().length) {
                  var cssText = getCssRulesString(n
                      .sheet);
                  if (cssText) {
                      attributes_1._cssText = absoluteToStylesheet(cssText, location.href);
                  }
              }
              if (tagName === 'input' ||
                  tagName === 'textarea' ||
                  tagName === 'select') {
                  var value = n.value;
                  if (attributes_1.type !== 'radio' &&
                      attributes_1.type !== 'checkbox' &&
                      value) {
                      attributes_1.value = value;
                  }
                  else if (n.checked) {
                      attributes_1.checked = n.checked;
                  }
              }
              if (tagName === 'option') {
                  var selectValue = n.parentElement;
                  if (attributes_1.value === selectValue.value) {
                      attributes_1.selected = n.selected;
                  }
              }
              if (needBlock_1) {
                  var _c = n.getBoundingClientRect(), width = _c.width, height = _c.height;
                  attributes_1.rr_width = width + "px";
                  attributes_1.rr_height = height + "px";
              }
              return {
                  type: exports.NodeType.Element,
                  tagName: tagName,
                  attributes: attributes_1,
                  childNodes: [],
                  isSVG: isSVGElement(n) || undefined,
                  needBlock: needBlock_1
              };
          case n.TEXT_NODE:
              var parentTagName = n.parentNode && n.parentNode.tagName;
              var textContent = n.textContent;
              var isStyle = parentTagName === 'STYLE' ? true : undefined;
              if (isStyle && textContent) {
                  textContent = absoluteToStylesheet(textContent, location.href);
              }
              if (parentTagName === 'SCRIPT') {
                  textContent = 'SCRIPT_PLACEHOLDER';
              }
              return {
                  type: exports.NodeType.Text,
                  textContent: textContent || '',
                  isStyle: isStyle
              };
          case n.CDATA_SECTION_NODE:
              return {
                  type: exports.NodeType.CDATA,
                  textContent: ''
              };
          case n.COMMENT_NODE:
              return {
                  type: exports.NodeType.Comment,
                  textContent: n.textContent || ''
              };
          default:
              return false;
      }
  }
  function serializeNodeWithId(n, doc, map, blockClass, skipChild, inlineStylesheet) {
      if (skipChild === void 0) { skipChild = false; }
      if (inlineStylesheet === void 0) { inlineStylesheet = true; }
      var _serializedNode = serializeNode(n, doc, blockClass, inlineStylesheet);
      if (!_serializedNode) {
          console.warn(n, 'not serialized');
          return null;
      }
      var id;
      if ('__sn' in n) {
          id = n.__sn.id;
      }
      else {
          id = genId();
      }
      var serializedNode = Object.assign(_serializedNode, { id: id });
      n.__sn = serializedNode;
      map[id] = n;
      var recordChild = !skipChild;
      if (serializedNode.type === exports.NodeType.Element) {
          recordChild = recordChild && !serializedNode.needBlock;
          delete serializedNode.needBlock;
      }
      if ((serializedNode.type === exports.NodeType.Document ||
          serializedNode.type === exports.NodeType.Element) &&
          recordChild) {
          for (var _i = 0, _a = Array.from(n.childNodes); _i < _a.length; _i++) {
              var childN = _a[_i];
              var serializedChildNode = serializeNodeWithId(childN, doc, map, blockClass, skipChild, inlineStylesheet);
              if (serializedChildNode) {
                  serializedNode.childNodes.push(serializedChildNode);
              }
          }
      }
      return serializedNode;
  }
  function snapshot(n, blockClass, inlineStylesheet) {
      if (blockClass === void 0) { blockClass = 'rr-block'; }
      if (inlineStylesheet === void 0) { inlineStylesheet = true; }
      var idNodeMap = {};
      return [
          serializeNodeWithId(n, n, idNodeMap, blockClass, false, inlineStylesheet),
          idNodeMap,
      ];
  }

  var tagMap = {
      script: 'noscript',
      altglyph: 'altGlyph',
      altglyphdef: 'altGlyphDef',
      altglyphitem: 'altGlyphItem',
      animatecolor: 'animateColor',
      animatemotion: 'animateMotion',
      animatetransform: 'animateTransform',
      clippath: 'clipPath',
      feblend: 'feBlend',
      fecolormatrix: 'feColorMatrix',
      fecomponenttransfer: 'feComponentTransfer',
      fecomposite: 'feComposite',
      feconvolvematrix: 'feConvolveMatrix',
      fediffuselighting: 'feDiffuseLighting',
      fedisplacementmap: 'feDisplacementMap',
      fedistantlight: 'feDistantLight',
      fedropshadow: 'feDropShadow',
      feflood: 'feFlood',
      fefunca: 'feFuncA',
      fefuncb: 'feFuncB',
      fefuncg: 'feFuncG',
      fefuncr: 'feFuncR',
      fegaussianblur: 'feGaussianBlur',
      feimage: 'feImage',
      femerge: 'feMerge',
      femergenode: 'feMergeNode',
      femorphology: 'feMorphology',
      feoffset: 'feOffset',
      fepointlight: 'fePointLight',
      fespecularlighting: 'feSpecularLighting',
      fespotlight: 'feSpotLight',
      fetile: 'feTile',
      feturbulence: 'feTurbulence',
      foreignobject: 'foreignObject',
      glyphref: 'glyphRef',
      lineargradient: 'linearGradient',
      radialgradient: 'radialGradient'
  };
  function getTagName(n) {
      var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;
      if (tagName === 'link' && n.attributes._cssText) {
          tagName = 'style';
      }
      return tagName;
  }
  var CSS_SELECTOR = /([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g;
  var HOVER_SELECTOR = /([^\\]):hover/g;
  function addHoverClass(cssText) {
      return cssText.replace(CSS_SELECTOR, function (match, p1, p2) {
          if (HOVER_SELECTOR.test(p1)) {
              var newSelector = p1.replace(HOVER_SELECTOR, '$1.\\:hover');
              return p1.replace(/\s*$/, '') + ", " + newSelector.replace(/^\s*/, '') + p2;
          }
          else {
              return match;
          }
      });
  }
  function buildNode(n, doc) {
      switch (n.type) {
          case exports.NodeType.Document:
              return doc.implementation.createDocument(null, '', null);
          case exports.NodeType.DocumentType:
              return doc.implementation.createDocumentType(n.name, n.publicId, n.systemId);
          case exports.NodeType.Element:
              var tagName = getTagName(n);
              var node = void 0;
              if (n.isSVG) {
                  node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);
              }
              else {
                  node = doc.createElement(tagName);
              }
              for (var name in n.attributes) {
                  if (n.attributes.hasOwnProperty(name) && !name.startsWith('rr_')) {
                      var value = n.attributes[name];
                      value = typeof value === 'boolean' ? '' : value;
                      var isTextarea = tagName === 'textarea' && name === 'value';
                      var isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';
                      if (isRemoteOrDynamicCss) {
                          value = addHoverClass(value);
                      }
                      if (isTextarea || isRemoteOrDynamicCss) {
                          var child = doc.createTextNode(value);
                          node.appendChild(child);
                          continue;
                      }
                      if (tagName === 'iframe' && name === 'src') {
                          continue;
                      }
                      try {
                          if (n.isSVG && name === 'xlink:href') {
                              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);
                          }
                          else {
                              node.setAttribute(name, value);
                          }
                      }
                      catch (error) {
                      }
                  }
                  else {
                      if (n.attributes.rr_width) {
                          node.style.width = n.attributes.rr_width;
                      }
                      if (n.attributes.rr_height) {
                          node.style.height = n.attributes
                              .rr_height;
                      }
                  }
              }
              return node;
          case exports.NodeType.Text:
              return doc.createTextNode(n.isStyle ? addHoverClass(n.textContent) : n.textContent);
          case exports.NodeType.CDATA:
              return doc.createCDATASection(n.textContent);
          case exports.NodeType.Comment:
              return doc.createComment(n.textContent);
          default:
              return null;
      }
  }
  function buildNodeWithSN(n, doc, map, skipChild) {
      if (skipChild === void 0) { skipChild = false; }
      var node = buildNode(n, doc);
      if (!node) {
          return null;
      }
      if (n.type === exports.NodeType.Document) {
          doc.close();
          doc.open();
          node = doc;
      }
      node.__sn = n;
      map[n.id] = node;
      if ((n.type === exports.NodeType.Document || n.type === exports.NodeType.Element) &&
          !skipChild) {
          for (var _i = 0, _a = n.childNodes; _i < _a.length; _i++) {
              var childN = _a[_i];
              var childNode = buildNodeWithSN(childN, doc, map);
              if (!childNode) {
                  console.warn('Failed to rebuild', childN);
              }
              else {
                  node.appendChild(childNode);
              }
          }
      }
      return node;
  }
  function rebuild(n, doc) {
      var idNodeMap = {};
      return [buildNodeWithSN(n, doc, idNodeMap), idNodeMap];
  }

  exports.snapshot = snapshot;
  exports.serializeNodeWithId = serializeNodeWithId;
  exports.rebuild = rebuild;
  exports.buildNodeWithSN = buildNodeWithSN;

  return exports;

}({}));
