{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/snapshot.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode =\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode;\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n} from './types';\n\nlet _id = 1;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules\n      ? Array.from(rules).reduce(\n          (prev, cur) => prev + getCssRuleString(cur),\n          '',\n        )\n      : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url\n      .split('/')\n      .slice(0, 3)\n      .join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:'([^']*)'|\"([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/).*/;\nconst DATA_URI = /^(data:)([\\w\\/\\+]+);(charset=[\\w-]+|base64).*,(.*)/gi;\nexport function absoluteToStylesheet(cssText: string, href: string): string {\n  return cssText.replace(URL_IN_CSS_REF, (origin, path1, path2, path3) => {\n    const filePath = path1 || path2 || path3;\n    if (!filePath) {\n      return origin;\n    }\n    if (!RELATIVE_PATH.test(filePath)) {\n      return `url('${filePath}')`;\n    }\n    if (DATA_URI.test(filePath)) {\n      return `url(${filePath})`;\n    }\n    if (filePath[0] === '/') {\n      return `url('${extractOrigin(href) + filePath}')`;\n    }\n    const stack = href.split('/');\n    const parts = filePath.split('/');\n    stack.pop();\n    for (const part of parts) {\n      if (part === '.') {\n        continue;\n      } else if (part === '..') {\n        stack.pop();\n      } else {\n        stack.push(part);\n      }\n    }\n    return `url('${stack.join('/')}')`;\n  });\n}\n\nfunction absoluteToDoc(doc: Document, attributeValue: string): string {\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction serializeNode(\n  n: Node,\n  doc: Document,\n  blockClass: string | RegExp,\n  inlineStylesheet: boolean,\n): serializedNode | false {\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n      };\n    case n.ELEMENT_NODE:\n      let needBlock = false;\n      if (typeof blockClass === 'string') {\n        needBlock = (n as HTMLElement).classList.contains(blockClass);\n      } else {\n        (n as HTMLElement).classList.forEach(className => {\n          if (blockClass.test(className)) {\n            needBlock = true;\n          }\n        });\n      }\n      const tagName = (n as HTMLElement).tagName.toLowerCase();\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        // relative path in attribute\n        if (name === 'src' || name === 'href') {\n          attributes[name] = absoluteToDoc(doc, value);\n        } else if (name === 'style') {\n          attributes[name] = absoluteToStylesheet(value, location.href);\n        } else {\n          attributes[name] = value;\n        }\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find(s => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(n as HTMLElement).innerText.trim().length\n      ) {\n        const cssText = getCssRulesString((n as HTMLStyleElement)\n          .sheet as CSSStyleSheet);\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, location.href);\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          value\n        ) {\n          attributes.value = value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes.rr_width = `${width}px`;\n        attributes.rr_height = `${height}px`;\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, location.href);\n      }\n      if (parentTagName === 'SCRIPT') {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n      };\n    default:\n      return false;\n  }\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  doc: Document,\n  map: idNodeMap,\n  blockClass: string | RegExp,\n  skipChild = false,\n  inlineStylesheet = true,\n): serializedNodeWithId | null {\n  const _serializedNode = serializeNode(n, doc, blockClass, inlineStylesheet);\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  map[id] = n as INode;\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(\n        childN,\n        doc,\n        map,\n        blockClass,\n        skipChild,\n        inlineStylesheet,\n      );\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n  }\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  blockClass: string | RegExp = 'rr-block',\n  inlineStylesheet = true,\n): [serializedNodeWithId | null, idNodeMap] {\n  const idNodeMap: idNodeMap = {};\n  return [\n    serializeNodeWithId(n, n, idNodeMap, blockClass, false, inlineStylesheet),\n    idNodeMap,\n  ];\n}\n\nexport default snapshot;\n","import {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n} from './types';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\nconst CSS_SELECTOR = /([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)/g;\nconst HOVER_SELECTOR = /([^\\\\]):hover/g;\nexport function addHoverClass(cssText: string): string {\n  return cssText.replace(CSS_SELECTOR, (match, p1: string, p2: string) => {\n    if (HOVER_SELECTOR.test(p1)) {\n      const newSelector = p1.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n      return `${p1.replace(/\\s*$/, '')}, ${newSelector.replace(\n        /^\\s*/,\n        '',\n      )}${p2}`;\n    } else {\n      return match;\n    }\n  });\n}\n\nfunction buildNode(n: serializedNodeWithId, doc: Document): Node | null {\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name,\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (n.attributes.hasOwnProperty(name) && !name.startsWith('rr_')) {\n          let value = n.attributes[name];\n          value = typeof value === 'boolean' ? '' : value;\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss) {\n            value = addHoverClass(value);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            node.appendChild(child);\n            continue;\n          }\n          if (tagName === 'iframe' && name === 'src') {\n            continue;\n          }\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (n.attributes.rr_width) {\n            (node as HTMLElement).style.width = n.attributes.rr_width as string;\n          }\n          if (n.attributes.rr_height) {\n            (node as HTMLElement).style.height = n.attributes\n              .rr_height as string;\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle ? addHoverClass(n.textContent) : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  doc: Document,\n  map: idNodeMap,\n  skipChild = false,\n): INode | null {\n  let node = buildNode(n, doc);\n  if (!node) {\n    return null;\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, doc, map);\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n      } else {\n        node.appendChild(childNode);\n      }\n    }\n  }\n  return node as INode;\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  doc: Document,\n): [Node | null, idNodeMap] {\n  const idNodeMap: idNodeMap = {};\n  return [buildNodeWithSN(n, doc, idNodeMap), idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","_id","genId","getCssRulesString","s","rules","cssRules","Array","from","reduce","prev","cur","getCssRuleString","error","rule","isCSSImportRule","styleSheet","cssText","extractOrigin","url","indexOf","split","slice","join","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","path1","path2","path3","filePath","test","stack","parts","pop","parts_1","_i","part","push","absoluteToDoc","doc","attributeValue","a","createElement","isSVGElement","el","tagName","SVGElement","serializeNode","n","blockClass","inlineStylesheet","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","name","publicId","systemId","ELEMENT_NODE","needBlock_1","classList","contains","forEach","className","toLowerCase","attributes_1","_a","attributes","_b","value","location","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","trim","length","checked","selectValue","parentElement","selected","_c","width","height","rr_width","rr_height","Element","isSVG","undefined","needBlock","TEXT_NODE","parentTagName","parentNode","textContent","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNodeWithId","map","skipChild","id","_serializedNode","console","warn","__sn","serializedNode","Object","assign","recordChild","serializedChildNode","snapshot","idNodeMap","tagMap","script","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","getTagName","CSS_SELECTOR","HOVER_SELECTOR","addHoverClass","match","p1","p2","newSelector","buildNode","implementation","createDocument","createDocumentType","node","createElementNS","hasOwnProperty","startsWith","isTextarea","isRemoteOrDynamicCss","child","createTextNode","appendChild","setAttributeNS","setAttribute","style","createCDATASection","createComment","buildNodeWithSN","close","open","childN","childNode","rebuild"],"mappings":"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"}